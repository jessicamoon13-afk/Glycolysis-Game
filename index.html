<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Glycolysis Builder Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#121a33;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.08);
      --border: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --gold:#c9b037;
      --good:#45d483;
      --bad:#ff6b6b;
      --warn:#ffcc66;
      --shadow: 0 22px 52px rgba(0,0,0,0.45);
      --radius: 18px;

      --btn: rgba(255,255,255,0.08);
      --btnHover: rgba(255,255,255,0.13);
      --kbd: rgba(0,0,0,0.28);
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 700px at 20% 0%, #1a2452 0%, var(--bg1) 48%, #070a14 100%);
      min-height:100vh;
      padding: 18px;
    }

    .wrap{ max-width: 1220px; margin: 0 auto; }
    .top{
      display:flex; gap:14px; align-items:flex-end; justify-content: space-between;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    h1{ margin:0; font-size: 26px; letter-spacing: -0.4px; }
    .sub{ color: var(--muted); font-size: 14px; line-height: 1.35; max-width: 840px; }

    .bar{ display:flex; gap:10px; flex-wrap: wrap; align-items:center; justify-content:flex-end; }
    .pill{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.05);
      padding: 9px 12px;
      border-radius: 999px;
      display:flex; gap:8px; align-items:center;
      font-size: 13px;
    }
    .pill strong{ color: white; font-weight: 800; }
    .btn{
      border:1px solid var(--border);
      background: var(--btn);
      color: white;
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 760;
      letter-spacing: 0.1px;
      user-select:none;
    }
    .btn:hover{ background: var(--btnHover); }
    .btn.primary{
      background: rgba(201,176,55,0.92);
      color: #0b1020;
      border-color: rgba(201,176,55,0.8);
    }
    .btn.primary:hover{ background: rgba(201,176,55,1); }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 12px;
    }
    @media (max-width: 1000px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display:flex; align-items:center; justify-content: space-between; gap: 12px;
      flex-wrap: wrap;
    }
    .panelHeader h2{
      margin:0;
      font-size: 15px;
      letter-spacing: -0.2px;
      color: rgba(255,255,255,0.95);
      display:flex; gap: 10px; align-items:center;
    }
    .tag{
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      white-space: nowrap;
    }
    .panelBody{ padding: 14px 16px 16px; }

    .row{ display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .hr{ height:1px; background: var(--border); margin: 12px 0; }

    .instruction{ color: var(--muted); font-size: 14px; line-height: 1.45; }

    .toggleGroup{
      display:flex;
      border:1px solid var(--border);
      border-radius: 999px;
      overflow:hidden;
    }
    .toggle{
      padding: 9px 12px;
      cursor:pointer;
      user-select:none;
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      border-right: 1px solid var(--border);
      font-weight: 800;
      font-size: 13px;
    }
    .toggle:last-child{ border-right: none; }
    .toggle.active{
      background: rgba(201,176,55,0.92);
      color: #0b1020;
    }

    .miniGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 620px){
      .miniGrid{ grid-template-columns: 1fr; }
    }
    .miniPanel{
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .miniTitle{ font-weight: 850; font-size: 12px; color: rgba(255,255,255,0.92); }
    .miniText{ margin-top: 4px; font-size: 12px; color: rgba(255,255,255,0.72); line-height: 1.35; }

    .statsGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 850px){
      .statsGrid{ grid-template-columns: repeat(2, 1fr); }
    }
    .stat{
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .stat .k{ font-size: 11px; color: rgba(255,255,255,0.70); }
    .stat .v{ font-weight: 900; font-size: 16px; margin-top: 2px; }
    .stat.good .v{ color: var(--good); }
    .stat.gold .v{ color: rgba(201,176,55,0.98); }

    .progressWrap{
      margin-top: 10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .progressBar{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      overflow:hidden;
      margin-top: 8px;
    }
    .progressFill{
      height: 100%;
      width: 0%;
      background: rgba(201,176,55,0.92);
      border-radius: 999px;
      transition: width 160ms ease;
    }

    /* Slots */
    .slots{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }
    .slot{
      border:1px dashed rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
      min-height: 64px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      transition: 120ms ease;
    }
    .slot.dragOver{
      border-color: rgba(201,176,55,0.9);
      background: rgba(201,176,55,0.12);
      transform: translateY(-1px);
    }
    .slotLeft{
      display:flex;
      gap:10px;
      align-items:center;
      min-width: 140px;
    }
    .slotNum{
      width: 28px; height: 28px;
      border-radius: 12px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.06);
      font-weight: 900;
    }
    .slotLabel{
      display:flex; flex-direction: column;
      gap: 2px;
    }
    .slotLabel .main{
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,0.86);
    }
    .slotLabel .sub{
      font-size: 11px;
      color: rgba(255,255,255,0.62);
      max-width: 320px;
    }
    .slotRight{
      flex:1;
      display:flex;
      justify-content:flex-end;
      min-height: 44px;
      align-items:center;
      gap: 10px;
    }
    .slotBadge{
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: rgba(255,255,255,0.70);
      background: rgba(255,255,255,0.05);
      white-space: nowrap;
    }
    .slotBadge.good{ border-color: rgba(69,212,131,0.45); background: rgba(69,212,131,0.10); color: rgba(255,255,255,0.90); }
    .slotBadge.bad{ border-color: rgba(255,107,107,0.50); background: rgba(255,107,107,0.10); color: rgba(255,255,255,0.90); }
    .slotBadge.warn{ border-color: rgba(255,204,102,0.45); background: rgba(255,204,102,0.10); color: rgba(255,255,255,0.90); }

    /* Cards */
    .card{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: 10px 12px;
      display:flex;
      flex-direction: column;
      gap: 5px;
      cursor: grab;
      user-select:none;
      max-width: 520px;
    }
    .card:active{ cursor: grabbing; }

    .card .name{
      font-weight: 900;
      font-size: 14px;
      color: rgba(255,255,255,0.95);
      display:flex; gap: 8px; align-items:center; flex-wrap: wrap;
    }
    .chip{
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.16);
      color: rgba(255,255,255,0.74);
      font-weight: 850;
    }
    .chip.gold{ border-color: rgba(201,176,55,0.55); color: rgba(201,176,55,0.98); }
    .chip.good{ border-color: rgba(69,212,131,0.45); color: rgba(69,212,131,0.96); }
    .chip.bad{ border-color: rgba(255,107,107,0.55); color: rgba(255,107,107,0.96); }

    .card .meta{
      font-size: 12px;
      color: rgba(255,255,255,0.68);
      line-height: 1.35;
    }
    .card.selected{
      outline: 2px solid rgba(201,176,55,0.85);
      background: rgba(201,176,55,0.10);
    }

    .pool{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }
    .poolGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      min-height: 160px;
    }

    .status{
      margin-top: 10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
      color: rgba(255,255,255,0.84);
      font-size: 13px;
      line-height: 1.4;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      align-items:flex-start;
    }
    .status.good{ border-color: rgba(69,212,131,0.45); background: rgba(69,212,131,0.10); }
    .status.bad{ border-color: rgba(255,107,107,0.5); background: rgba(255,107,107,0.10); }
    .status.warn{ border-color: rgba(255,204,102,0.45); background: rgba(255,204,102,0.10); }
    .status .rightNote{
      color: rgba(255,255,255,0.68);
      font-size: 12px;
      white-space: nowrap;
    }

    .kbd{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--kbd);
      font-size: 11px;
      color: rgba(255,255,255,0.78);
      font-weight: 850;
      margin: 0 2px;
    }

    /* Overlay modal */
    .overlay{
      position: fixed;
      inset:0;
      background: rgba(0,0,0,0.62);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 30;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(920px, 100%);
      border-radius: 22px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.09), rgba(255,255,255,0.05));
      box-shadow: 0 30px 70px rgba(0,0,0,0.6);
      overflow:hidden;
    }
    .modalHeader{
      padding: 16px 18px;
      border-bottom: 1px solid var(--border);
      display:flex; align-items:center; justify-content: space-between; gap: 10px;
      flex-wrap: wrap;
    }
    .modalHeader h3{ margin:0; font-size: 16px; }
    .modalBody{ padding: 16px 18px 18px; }
    .scenario{
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 18px;
      padding: 12px 14px;
      margin-bottom: 12px;
    }
    .choices{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 720px){
      .choices{ grid-template-columns: 1fr; }
    }
    .choice{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: 12px 12px;
      cursor:pointer;
      transition: 120ms ease;
      user-select:none;
    }
    .choice:hover{ background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    .choice .ctitle{ font-weight: 900; }
    .choice .cmeta{ font-size: 12px; color: rgba(255,255,255,0.70); margin-top: 4px; line-height: 1.35; }

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.50);
      color: rgba(255,255,255,0.92);
      font-size: 13px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.55);
      z-index: 60;
      display:none;
      max-width: min(680px, 92vw);
    }
    .toast.show{ display:block; animation: pop 140ms ease; }
    @keyframes pop{ from{ transform: translateX(-50%) translateY(6px); opacity:0; } to{ transform: translateX(-50%) translateY(0); opacity:1; } }

    /* Confetti canvas */
    #confetti{
      position: fixed;
      inset: 0;
      pointer-events:none;
      z-index: 80;
      display:none;
    }
  </style>
</head>

<body>
  <canvas id="confetti"></canvas>
  <div class="toast" id="toast"></div>

  <div class="wrap">
    <div class="top">
      <div>
        <h1>Glycolysis Builder</h1>
        <div class="sub">
          Drag steps into the correct order. Toggle glucose vs glycogen. Watch ATP and NADH update as you build.
          Then do a quick finale on pyruvate fate.
        </div>
      </div>

      <div class="bar">
        <div class="pill"><strong>Score</strong> <span id="scoreVal">0</span></div>
        <div class="pill"><strong>Streak</strong> <span id="streakVal">0</span></div>
        <div class="pill"><strong>Time</strong> <span id="timeVal">0:00</span></div>

        <button class="btn" id="soundBtn" title="Toggle sound">Sound: On</button>
        <button class="btn" id="confettiBtn" title="Toggle confetti">Confetti: On</button>

        <button class="btn" id="undoBtn" title="Undo last move">Undo</button>
        <button class="btn" id="shuffleBtn" title="Shuffle pool">Shuffle</button>
        <button class="btn" id="hintBtn" title="Get a hint">Hint</button>
        <button class="btn" id="resetBtn" title="Reset everything">Reset</button>
        <button class="btn primary" id="checkBtn" title="Check pathway">Check</button>
      </div>
    </div>

    <div class="grid">
      <!-- Builder -->
      <div class="panel">
        <div class="panelHeader">
          <h2>Build the pathway <span class="tag" id="modeTag">Study Mode</span> <span class="tag" id="startTag">Start: Glucose</span></h2>
          <div class="row">
            <div class="toggleGroup" aria-label="Start substrate toggle">
              <div class="toggle active" id="glucoseToggle">Glucose</div>
              <div class="toggle" id="glycogenToggle">Glycogen</div>
            </div>

            <div class="toggleGroup" aria-label="Game mode toggle">
              <div class="toggle active" id="studyToggle">Study</div>
              <div class="toggle" id="challengeToggle">Challenge</div>
            </div>
          </div>
        </div>

        <div class="panelBody">
          <div class="instruction">
            Drag cards into slots. Or use keyboard:
            click a card to select, then click a slot to place. Return a card to the pool by double clicking it.
            Check with <span class="kbd">Enter</span>, hint with <span class="kbd">H</span>, reset with <span class="kbd">R</span>.
          </div>

          <div class="miniGrid">
            <div class="miniPanel">
              <div class="miniTitle">What to focus on</div>
              <div class="miniText" id="focusText">
                Anchor the order with irreversible steps (HK, PFK 1, PK). NADH is made at GAPDH. ATP is made at PGK and PK.
              </div>
            </div>
            <div class="miniPanel">
              <div class="miniTitle">Start note</div>
              <div class="miniText" id="startNote">
                Starting from glucose: invest 2 ATP, make 4 ATP, net 2 ATP. NADH = 2.
              </div>
            </div>
          </div>

          <div class="statsGrid">
            <div class="stat">
              <div class="k">ATP used</div>
              <div class="v" id="atpUsedVal">0</div>
            </div>
            <div class="stat good">
              <div class="k">ATP made</div>
              <div class="v" id="atpMadeVal">0</div>
            </div>
            <div class="stat gold">
              <div class="k">Net ATP</div>
              <div class="v" id="netAtpVal">0</div>
            </div>
            <div class="stat">
              <div class="k">NADH made</div>
              <div class="v" id="nadhVal">0</div>
            </div>
          </div>

          <div class="progressWrap">
            <div class="miniTitle">Progress</div>
            <div class="progressBar" aria-label="Progress bar">
              <div class="progressFill" id="progressFill"></div>
            </div>
            <div class="miniText" id="progressText">Place cards to start.</div>
          </div>

          <div class="hr"></div>

          <div class="slots" id="slots"></div>

          <div class="status warn" id="statusBox">
            <div id="statusMsg">Build your pathway, then click Check. Perfect unlocks the pyruvate finale.</div>
            <div class="rightNote" id="hintNote">Hints left: 3</div>
          </div>
        </div>
      </div>

      <!-- Pool -->
      <div class="panel">
        <div class="panelHeader">
          <h2>Card pool <span class="tag" id="poolTag">Click to place</span></h2>
          <div class="tag" id="badgesTag">Badges: 0</div>
        </div>
        <div class="panelBody">
          <div class="instruction">
            Drag a card into a slot. Or click a card, then click a slot.
            If you want to change wording, search for <span class="kbd">TEACHER SETTINGS</span> in the code.
          </div>

          <div class="pool">
            <div class="poolGrid" id="pool"></div>
          </div>

          <div class="hr"></div>

          <div class="miniPanel">
            <div class="miniTitle">Quick badges students like</div>
            <div class="miniText" id="badgeList">
              First Try, No Hints, Fast Finish, Perfect 3x.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Finale modal -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHeader">
        <h3>Finale: fate of pyruvate</h3>
        <div class="row">
          <span class="tag" id="finaleTag">Unlocked</span>
          <button class="btn" id="newScenarioBtn">New scenario</button>
          <button class="btn" id="closeOverlayBtn">Close</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="scenario" id="scenarioBox"></div>

        <div class="choices" id="choices"></div>

        <div class="status warn" id="finaleFeedback" style="margin-top: 12px;">
          Pick the best fate for pyruvate based on the scenario.
        </div>

        <div class="miniText" style="margin-top: 10px;">
          Tip: when oxygen is available, route to acetyl CoA for higher ATP. When oxygen is limited or demand is extreme, lactate regenerates NAD+.
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // TEACHER SETTINGS
    // =========================
    const SETTINGS = {
      // Scoring
      scorePerfectBase: 30,
      scorePerfectDecay: 5,      // reduce bonus after each failed check
      scoreWrongCheck: -4,
      scoreHint: -1,
      scoreFinaleCorrect: 12,
      scoreFinaleWrong: -2,

      // Hints
      hintsStudy: 3,
      hintsChallenge: 1,

      // Timer thresholds for badges (seconds)
      badgeFastFinishUnder: 90,

      // Confetti intensity
      confettiParticles: 150,

      // Challenge mode tweaks
      challengeNoPerSlotHelpUntilCheck: true
    };

    // Compact pathway (clean for students). If you want the full 10 steps, tell me and I will swap it in.
    // Each card has effect tags so energy accounting updates live.
    const CARDS = [
      {
        id: "start_glucose",
        name: "Start: Glucose",
        meta: "Glucose is available in cytosol.",
        chips: ["START"],
        onlyWhen: "glucose",
        effects: {}
      },
      {
        id: "start_glycogen",
        name: "Start: Glycogen entry",
        meta: "Glycogen -> G1P -> G6P. Bypasses HK ATP cost.",
        chips: ["START", "BYPASS HK"],
        onlyWhen: "glycogen",
        effects: {}
      },
      {
        id: "hk",
        name: "Hexokinase (HK)",
        meta: "Glucose -> G6P. ATP used. Traps glucose in cell.",
        chips: ["ATP USE", "IRREV"],
        effects: { atpUsed: 1 }
      },
      {
        id: "pfk",
        name: "PFK 1",
        meta: "F6P -> F1,6BP. ATP used. Major control point.",
        chips: ["ATP USE", "CONTROL", "IRREV"],
        effects: { atpUsed: 1 }
      },
      {
        id: "split",
        name: "Split and rearrange",
        meta: "F1,6BP -> 2 x triose phosphates. Sets up payoff.",
        chips: ["2X"],
        effects: {}
      },
      {
        id: "gapdh",
        name: "GAPDH",
        meta: "G3P -> 1,3BPG. NAD+ -> NADH.",
        chips: ["NADH"],
        effects: { nadh: 2 } // happens twice per glucose
      },
      {
        id: "pgk",
        name: "Phosphoglycerate kinase (PGK)",
        meta: "1,3BPG -> 3PG. ATP made (substrate level).",
        chips: ["ATP MAKE"],
        effects: { atpMade: 2 } // happens twice
      },
      {
        id: "pk",
        name: "Pyruvate kinase (PK)",
        meta: "PEP -> Pyruvate. ATP made. Irreversible.",
        chips: ["ATP MAKE", "IRREV"],
        effects: { atpMade: 2 } // happens twice
      }
    ];

    // Correct order differs by start
    const ORDER = {
      glucose: ["start_glucose", "hk", "pfk", "split", "gapdh", "pgk", "pk"],
      glycogen: ["start_glycogen", "pfk", "split", "gapdh", "pgk", "pk"]
    };

    const START_NOTES = {
      glucose: "Starting from glucose: invest 2 ATP, make 4 ATP, net 2 ATP. NADH = 2.",
      glycogen: "Starting from glycogen: you bypass the HK ATP cost, so net ATP is higher by 1 (net 3). NADH = 2."
    };

    // Finale: only two fates
    const FATE_CHOICES = [
      {
        id: "acetylCoA",
        title: "Acetyl CoA (aerobic)",
        meta: "Oxygen available. Pyruvate enters mitochondria (PDH) to support aerobic ATP production."
      },
      {
        id: "lactate",
        title: "Lactate (anaerobic or very high flux)",
        meta: "Regenerates NAD+ so glycolysis can continue when oxygen is limited or demand is very high."
      }
    ];

    const SCENARIOS = [
      { id: "highO2", prompt: "Oxygen is plentiful and mitochondria are ready. You want maximum ATP yield.", correct: "acetylCoA" },
      { id: "lowO2", prompt: "Very low oxygen during an all out sprint. You must regenerate NAD+ fast.", correct: "lactate" },
      { id: "steady", prompt: "Moderate intensity with steady breathing. Oxygen is adequate.", correct: "acetylCoA" },
      { id: "allOut", prompt: "All out effort. Glycolysis is flying and oxygen delivery cannot keep up.", correct: "lactate" }
    ];

    // =========================
    // STATE
    // =========================
    const state = {
      start: "glucose",
      mode: "study", // study or challenge
      score: 0,
      streak: 0,
      badges: new Set(),
      attempts: 0,
      hintsLeft: SETTINGS.hintsStudy,
      hintLevel: 0,
      placedBySlot: [],
      slotFeedback: [],
      history: [], // undo stack: {cardId, from, to, toSlotIndex}
      selectedCardId: null,

      // Timer
      timerOn: false,
      t0: 0,
      elapsed: 0,
      timerHandle: 0,

      // Finale
      finaleUnlocked: false,
      currentScenario: null,
      finaleSolvedCount: 0,

      // UX
      soundOn: true,
      confettiOn: true
    };

    // =========================
    // ELEMENTS
    // =========================
    const el = (id) => document.getElementById(id);

    const scoreVal = el("scoreVal");
    const streakVal = el("streakVal");
    const timeVal = el("timeVal");
    const badgesTag = el("badgesTag");
    const startTag = el("startTag");
    const modeTag = el("modeTag");
    const startNote = el("startNote");
    const statusBox = el("statusBox");
    const statusMsg = el("statusMsg");
    const hintNote = el("hintNote");

    const atpUsedVal = el("atpUsedVal");
    const atpMadeVal = el("atpMadeVal");
    const netAtpVal = el("netAtpVal");
    const nadhVal = el("nadhVal");

    const progressFill = el("progressFill");
    const progressText = el("progressText");

    const pool = el("pool");
    const slots = el("slots");

    const overlay = el("overlay");
    const scenarioBox = el("scenarioBox");
    const choicesEl = el("choices");
    const finaleFeedback = el("finaleFeedback");

    const toast = el("toast");
    const confettiCanvas = el("confetti");
    const ctxConf = confettiCanvas.getContext("2d");

    // =========================
    // UTILS
    // =========================
    function escapeHtml(str){
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function shuffle(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function beep(type){
      if (!state.soundOn) return;
      // Simple WebAudio beeps, no external files
      try{
        const ac = new (window.AudioContext || window.webkitAudioContext)();
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.connect(g);
        g.connect(ac.destination);

        let f = 440, dur = 0.08, gain = 0.06;
        if (type === "good"){ f = 660; dur = 0.10; }
        if (type === "bad"){ f = 220; dur = 0.10; }
        if (type === "click"){ f = 520; dur = 0.05; gain = 0.04; }

        o.frequency.value = f;
        o.type = "sine";
        g.gain.value = gain;

        o.start();
        setTimeout(() => { o.stop(); ac.close(); }, Math.floor(dur * 1000));
      } catch {
        // ignore
      }
    }

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove("show"), 1600);
    }

    function setStatus(msg, kind){
      statusBox.classList.remove("good","bad","warn");
      statusBox.classList.add(kind);
      statusMsg.textContent = msg;
    }

    function setFinaleStatus(msg, kind){
      finaleFeedback.classList.remove("good","bad","warn");
      finaleFeedback.classList.add(kind);
      finaleFeedback.textContent = msg;
    }

    function formatTime(sec){
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m}:${String(s).padStart(2,"0")}`;
    }

    // =========================
    // CONFETTI
    // =========================
    function confettiBurst(){
      if (!state.confettiOn) return;
      resizeConfetti();
      confettiCanvas.style.display = "block";

      const W = confettiCanvas.width;
      const H = confettiCanvas.height;

      const parts = [];
      const n = SETTINGS.confettiParticles;

      for (let i = 0; i < n; i++){
        parts.push({
          x: Math.random() * W,
          y: -20 - Math.random() * 200,
          vx: -2 + Math.random() * 4,
          vy: 2 + Math.random() * 5,
          r: 2 + Math.random() * 4,
          a: Math.random() * Math.PI * 2,
          va: -0.2 + Math.random() * 0.4,
          life: 80 + Math.random() * 80
        });
      }

      let frame = 0;
      function tick(){
        frame++;
        ctxConf.clearRect(0,0,W,H);
        for (const p of parts){
          p.x += p.vx;
          p.y += p.vy;
          p.a += p.va;
          p.vy += 0.02;
          p.life--;

          ctxConf.save();
          ctxConf.translate(p.x, p.y);
          ctxConf.rotate(p.a);
          ctxConf.globalAlpha = Math.max(0, Math.min(1, p.life / 60));
          ctxConf.fillStyle = (Math.random() < 0.5) ? "rgba(201,176,55,0.95)" : "rgba(255,255,255,0.85)";
          ctxConf.fillRect(-p.r, -p.r, p.r*2, p.r*2);
          ctxConf.restore();
        }

        if (parts.some(p => p.life > 0 && p.y < H + 40)){
          requestAnimationFrame(tick);
        } else {
          confettiCanvas.style.display = "none";
        }
      }
      requestAnimationFrame(tick);
    }

    function resizeConfetti(){
      confettiCanvas.width = Math.floor(window.innerWidth * Math.min(2, window.devicePixelRatio || 1));
      confettiCanvas.height = Math.floor(window.innerHeight * Math.min(2, window.devicePixelRatio || 1));
      ctxConf.setTransform(1,0,0,1,0,0);
      // Scale drawing back to CSS pixels
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      ctxConf.scale(dpr, dpr);
    }

    window.addEventListener("resize", resizeConfetti);

    // =========================
    // TIMER
    // =========================
    function timerStart(){
      if (state.timerOn) return;
      state.timerOn = true;
      state.t0 = performance.now();
      state.elapsed = 0;
      updateTimeUI();
      state.timerHandle = setInterval(() => {
        state.elapsed = (performance.now() - state.t0) / 1000;
        updateTimeUI();
      }, 200);
    }

    function timerStop(){
      state.timerOn = false;
      clearInterval(state.timerHandle);
      state.timerHandle = 0;
      updateTimeUI();
    }

    function updateTimeUI(){
      timeVal.textContent = formatTime(state.elapsed);
    }

    // =========================
    // CARDS AND ORDER
    // =========================
    function getActiveCards(){
      return CARDS.filter(c => !c.onlyWhen || c.onlyWhen === state.start);
    }

    function getOrder(){
      return ORDER[state.start];
    }

    function getCardById(id){
      return CARDS.find(c => c.id === id);
    }

    function chipsHTML(card){
      const chips = (card.chips || []).map(ch => {
        let cls = "chip";
        if (ch.includes("ATP")) cls += " good";
        if (ch.includes("IRREV") || ch.includes("CONTROL")) cls += " gold";
        if (ch.includes("BYPASS")) cls += " gold";
        if (ch.includes("NADH")) cls += " good";
        return `<span class="${cls}">${escapeHtml(ch)}</span>`;
      }).join("");
      return chips;
    }

    // =========================
    // BUILD UI
    // =========================
    function buildSlots(){
      slots.innerHTML = "";
      const order = getOrder();
      state.placedBySlot = new Array(order.length).fill(null);
      state.slotFeedback = new Array(order.length).fill("empty");

      for (let i = 0; i < order.length; i++){
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.slotIndex = String(i);

        const left = document.createElement("div");
        left.className = "slotLeft";

        const num = document.createElement("div");
        num.className = "slotNum";
        num.textContent = String(i + 1);

        const label = document.createElement("div");
        label.className = "slotLabel";

        const main = document.createElement("div");
        main.className = "main";
        main.textContent = (i === 0) ? "Entry" : (i <= 2 ? "Early" : (i === 3 ? "Split" : "Payoff"));

        const sub = document.createElement("div");
        sub.className = "sub";
        sub.textContent = "Drop a card here";

        label.appendChild(main);
        label.appendChild(sub);

        left.appendChild(num);
        left.appendChild(label);

        const right = document.createElement("div");
        right.className = "slotRight";

        const badge = document.createElement("div");
        badge.className = "slotBadge warn";
        badge.textContent = "Empty";

        const content = document.createElement("div");
        content.dataset.dropzone = "slot";
        content.style.display = "flex";
        content.style.justifyContent = "flex-end";

        right.appendChild(badge);
        right.appendChild(content);

        slot.appendChild(left);
        slot.appendChild(right);

        slot.addEventListener("dragover", (e) => {
          e.preventDefault();
          slot.classList.add("dragOver");
        });
        slot.addEventListener("dragleave", () => slot.classList.remove("dragOver"));
        slot.addEventListener("drop", (e) => {
          e.preventDefault();
          slot.classList.remove("dragOver");
          const cardId = e.dataTransfer.getData("text/plain");
          if (cardId) placeCardIntoSlot(cardId, i, "drag");
        });

        // click to place if selected card exists
        slot.addEventListener("click", () => {
          if (state.selectedCardId){
            placeCardIntoSlot(state.selectedCardId, i, "click");
          }
        });

        slots.appendChild(slot);
      }
    }

    function buildPool(){
      pool.innerHTML = "";
      const shuffled = shuffle(getActiveCards());
      for (const c of shuffled){
        pool.appendChild(makeCard(c));
      }

      pool.addEventListener("dragover", (e) => e.preventDefault());
      pool.addEventListener("drop", (e) => {
        e.preventDefault();
        const cardId = e.dataTransfer.getData("text/plain");
        if (cardId) moveCardToPool(cardId, true);
      });
    }

    function makeCard(card){
      const d = document.createElement("div");
      d.className = "card";
      d.draggable = true;
      d.dataset.cardId = card.id;

      d.innerHTML = `
        <div class="name">${escapeHtml(card.name)} ${chipsHTML(card)}</div>
        <div class="meta">${escapeHtml(card.meta)}</div>
      `;

      d.addEventListener("dragstart", (e) => {
        e.dataTransfer.setData("text/plain", card.id);
        e.dataTransfer.effectAllowed = "move";
        beep("click");
      });

      d.addEventListener("click", (e) => {
        e.stopPropagation();
        selectCard(card.id);
        beep("click");
      });

      d.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        const fromSlot = findCardSlotIndex(card.id);
        if (fromSlot !== -1){
          moveCardToPool(card.id, true);
          pushHistory({ type:"toPool", cardId: card.id, fromSlot });
        }
      });

      return d;
    }

    function selectCard(cardId){
      // toggle selection
      if (state.selectedCardId === cardId){
        state.selectedCardId = null;
      } else {
        state.selectedCardId = cardId;
      }
      refreshSelectionUI();
    }

    function refreshSelectionUI(){
      document.querySelectorAll(".card").forEach(c => c.classList.remove("selected"));
      if (state.selectedCardId){
        const elCard = findCardElement(state.selectedCardId);
        if (elCard) elCard.classList.add("selected");
      }
    }

    function findCardElement(cardId){
      return document.querySelector(`[data-card-id="${cardId}"]`);
    }

    function findCardSlotIndex(cardId){
      return state.placedBySlot.findIndex(id => id === cardId);
    }

    function setSlotBadge(i, kind, text){
      const slot = document.querySelector(`.slot[data-slot-index="${i}"]`);
      if (!slot) return;
      const badge = slot.querySelector(".slotBadge");
      badge.classList.remove("good","bad","warn");
      badge.classList.add(kind);
      badge.textContent = text;
    }

    // =========================
    // HISTORY AND UNDO
    // =========================
    function pushHistory(entry){
      state.history.push(entry);
      if (state.history.length > 80) state.history.shift();
    }

    function undo(){
      const h = state.history.pop();
      if (!h){
        showToast("Nothing to undo.");
        return;
      }

      if (h.type === "place"){
        // remove from toSlot, restore old states
        if (h.toSlotIndex != null){
          clearSlot(h.toSlotIndex);
        }
        if (h.fromSlotIndex != null){
          // was moved from another slot, put back
          placeCardIntoSlot(h.cardId, h.fromSlotIndex, "undo", true);
        } else {
          // was from pool, send back to pool
          moveCardToPool(h.cardId, false);
        }
        // restore bumped card
        if (h.bumpedCardId){
          // bumped card went to pool, attempt to restore into slot
          placeCardIntoSlot(h.bumpedCardId, h.toSlotIndex, "undo", true);
        }
      }

      if (h.type === "toPool"){
        // try to put it back where it was
        placeCardIntoSlot(h.cardId, h.fromSlot, "undo", true);
      }

      computeEnergyAndProgress();
      if (state.selectedCardId && !findCardElement(state.selectedCardId)){
        state.selectedCardId = null;
      }
      refreshSelectionUI();
      showToast("Undo.");
      beep("click");
    }

    // =========================
    // PLACE AND MOVE
    // =========================
    function clearSlot(slotIndex){
      const slotContent = document.querySelector(`.slot[data-slot-index="${slotIndex}"] [data-dropzone="slot"]`);
      if (slotContent) slotContent.innerHTML = "";
      state.placedBySlot[slotIndex] = null;
      state.slotFeedback[slotIndex] = "empty";
      setSlotBadge(slotIndex, "warn", "Empty");
    }

    function placeCardIntoSlot(cardId, slotIndex, source, silent){
      const cardEl = findCardElement(cardId);
      if (!cardEl) return;

      timerStart();

      // already in some slot
      const existingSlot = findCardSlotIndex(cardId);
      if (existingSlot !== -1){
        clearSlot(existingSlot);
      }

      // bump existing card in target slot back to pool
      const existingInTarget = state.placedBySlot[slotIndex];
      let bumpedCardId = null;
      if (existingInTarget){
        bumpedCardId = existingInTarget;
        moveCardToPool(existingInTarget, false);
        clearSlot(slotIndex);
      }

      // place
      state.placedBySlot[slotIndex] = cardId;
      const slotContent = document.querySelector(`.slot[data-slot-index="${slotIndex}"] [data-dropzone="slot"]`);
      slotContent.innerHTML = "";
      slotContent.appendChild(cardEl);

      // record history for undo (skip during undo itself)
      if (source !== "undo"){
        pushHistory({
          type: "place",
          cardId,
          fromSlotIndex: existingSlot !== -1 ? existingSlot : null,
          toSlotIndex: slotIndex,
          bumpedCardId
        });
      }

      // if click placement, clear selection
      if (source === "click"){
        state.selectedCardId = null;
        refreshSelectionUI();
      } else {
        refreshSelectionUI();
      }

      // slot badge behavior
      if (!silent){
        setStatus("Nice. Keep building, then check.", "warn");
      }

      computeEnergyAndProgress();

      if (!silent) beep("click");
      if (state.mode === "challenge" && SETTINGS.challengeNoPerSlotHelpUntilCheck){
        // keep badges neutral until check
        setSlotBadge(slotIndex, "warn", "Placed");
      } else {
        // show "Placed" until check
        setSlotBadge(slotIndex, "warn", "Placed");
      }
    }

    function moveCardToPool(cardId, clearFromSlot){
      const cardEl = findCardElement(cardId);
      if (!cardEl) return;

      const slotIndex = findCardSlotIndex(cardId);
      if (slotIndex !== -1 && clearFromSlot){
        clearSlot(slotIndex);
      }

      pool.prepend(cardEl);
      if (state.selectedCardId === cardId){
        state.selectedCardId = null;
        refreshSelectionUI();
      }
    }

    // =========================
    // ENERGY AND PROGRESS
    // =========================
    function computeEnergyAndProgress(){
      let atpUsed = 0, atpMade = 0, nadh = 0;

      for (const id of state.placedBySlot){
        if (!id) continue;
        const card = getCardById(id);
        if (!card || !card.effects) continue;
        atpUsed += (card.effects.atpUsed || 0);
        atpMade += (card.effects.atpMade || 0);
        nadh += (card.effects.nadh || 0);
      }

      // glycogen bypass is explained in start card, but net reflects the placements
      // Special case: in glycogen mode, HK card is not part of correct order. But if you include it by dragging (still possible if not filtered). We filter it out by start, so fine.

      const netAtp = atpMade - atpUsed;

      atpUsedVal.textContent = String(atpUsed);
      atpMadeVal.textContent = String(atpMade);
      netAtpVal.textContent = String(netAtp);
      nadhVal.textContent = String(nadh);

      const filled = state.placedBySlot.filter(Boolean).length;
      const total = state.placedBySlot.length;
      const pct = total ? Math.round((filled / total) * 100) : 0;
      progressFill.style.width = pct + "%";
      progressText.textContent = filled === 0 ? "Place cards to start." : `Placed ${filled} of ${total}.`;

      // Update hint note
      hintNote.textContent = `Hints left: ${state.hintsLeft}`;

      // Tag updates
      startTag.textContent = "Start: " + (state.start === "glucose" ? "Glucose" : "Glycogen");
      modeTag.textContent = (state.mode === "study") ? "Study Mode" : "Challenge Mode";
    }

    // =========================
    // CHECK PATHWAY
    // =========================
    function updateScore(delta){
      state.score += delta;
      if (state.score < 0) state.score = 0;
      scoreVal.textContent = String(state.score);
    }

    function updateStreak(ok){
      if (ok){
        state.streak += 1;
        streakVal.textContent = String(state.streak);
      } else {
        state.streak = 0;
        streakVal.textContent = "0";
      }
    }

    function awardBadge(key, label){
      if (state.badges.has(key)) return;
      state.badges.add(key);
      badgesTag.textContent = "Badges: " + state.badges.size;
      showToast("Badge earned: " + label);
      beep("good");
    }

    function checkPathway(){
      const correct = getOrder();
      const placed = state.placedBySlot;

      // empty slots
      const emptyCount = placed.filter(x => !x).length;
      if (emptyCount > 0){
        setStatus(`You still have ${emptyCount} empty slot(s). Fill them first.`, "warn");
        beep("bad");
        return;
      }

      state.attempts += 1;

      let right = 0;
      for (let i = 0; i < correct.length; i++){
        if (placed[i] === correct[i]) right++;
      }

      // per slot feedback
      for (let i = 0; i < correct.length; i++){
        const ok = placed[i] === correct[i];
        if (ok){
          state.slotFeedback[i] = "good";
          setSlotBadge(i, "good", "Correct");
        } else {
          state.slotFeedback[i] = "bad";
          setSlotBadge(i, "bad", "Wrong");
        }
      }

      if (right === correct.length){
        const bonus = Math.max(10, SETTINGS.scorePerfectBase - (state.attempts - 1) * SETTINGS.scorePerfectDecay);
        updateScore(bonus);
        updateStreak(true);

        // unlock finale
        state.finaleUnlocked = true;

        // badges
        if (state.attempts === 1) awardBadge("first_try", "First Try");
        if (state.hintLevel === 0) awardBadge("no_hints", "No Hints");
        if (state.elapsed > 0 && state.elapsed <= SETTINGS.badgeFastFinishUnder) awardBadge("fast_finish", "Fast Finish");
        if (state.streak >= 3) awardBadge("perfect_3", "Perfect 3x");

        setStatus(`Correct. Bonus +${bonus}. Finale unlocked.`, "good");
        beep("good");
        confettiBurst();
        openFinale();
      } else {
        updateScore(SETTINGS.scoreWrongCheck);
        updateStreak(false);

        // hints guidance
        const miss = correct.length - right;
        let msg = `Not quite. You have ${right}/${correct.length} correct. ${miss} misplaced.`;
        if (state.mode === "study"){
          msg += " Try hint or move your anchors (HK, PFK 1, PK).";
        } else {
          msg += " Challenge mode: fewer hints. Rebuild quickly.";
        }
        setStatus(msg, "bad");
        beep("bad");

        if (state.mode === "study" && state.attempts >= 3){
          setStatus(msg + " Tip: NADH is made at GAPDH. ATP is made at PGK and PK.", "bad");
        }
      }
    }

    // =========================
    // HINTS
    // =========================
    function hint(){
      if (state.hintsLeft <= 0){
        showToast("No hints left.");
        beep("bad");
        return;
      }
      state.hintsLeft -= 1;
      state.hintLevel += 1;
      updateScore(SETTINGS.scoreHint);

      if (state.hintLevel === 1){
        setStatus("Hint: Put the START card first. Put PFK 1 early. It is the main control point.", "warn");
      } else if (state.hintLevel === 2){
        setStatus("Hint: NADH is made at GAPDH. ATP is made at PGK and PK (both happen twice).", "warn");
      } else {
        setStatus("Hint: Split happens before payoff. The payoff order is GAPDH then PGK then PK.", "warn");
      }
      computeEnergyAndProgress();
      beep("click");
    }

    // =========================
    // FINALE
    // =========================
    function pickScenario(){
      return SCENARIOS[Math.floor(Math.random() * SCENARIOS.length)];
    }

    function openFinale(){
      if (!state.finaleUnlocked){
        setStatus("Finish the pathway first to unlock the finale.", "warn");
        return;
      }
      state.currentScenario = pickScenario();
      el("finaleTag").textContent = "Unlocked";

      scenarioBox.innerHTML = `
        <div style="font-weight:900; margin-bottom: 6px; color: rgba(255,255,255,0.95);">Scenario</div>
        <div style="color: rgba(255,255,255,0.80); line-height: 1.45;">${escapeHtml(state.currentScenario.prompt)}</div>
      `;

      choicesEl.innerHTML = "";
      const shuffled = shuffle(FATE_CHOICES);
      for (const c of shuffled){
        const div = document.createElement("div");
        div.className = "choice";
        div.innerHTML = `
          <div class="ctitle">${escapeHtml(c.title)}</div>
          <div class="cmeta">${escapeHtml(c.meta)}</div>
        `;
        div.addEventListener("click", () => chooseFate(c.id));
        choicesEl.appendChild(div);
      }

      setFinaleStatus("Pick the best fate for pyruvate based on the scenario.", "warn");
      overlay.classList.add("show");
    }

    function chooseFate(choiceId){
      const s = state.currentScenario;
      if (!s) return;

      if (choiceId === s.correct){
        updateScore(SETTINGS.scoreFinaleCorrect);
        state.finaleSolvedCount += 1;

        const explain = (choiceId === "acetylCoA")
          ? "Correct. Oxygen is available, so pyruvate goes to acetyl CoA for aerobic ATP production."
          : "Correct. Oxygen is limited or demand is extreme, so lactate regenerates NAD+ to keep glycolysis running.";

        setFinaleStatus(explain + ` +${SETTINGS.scoreFinaleCorrect}.`, "good");
        beep("good");
        confettiBurst();

        // small badge if they nail a few finales
        if (state.finaleSolvedCount >= 3) awardBadge("finale_3", "Finale 3x");

      } else {
        updateScore(SETTINGS.scoreFinaleWrong);
        const explain = (choiceId === "acetylCoA")
          ? "Not quite. That would be best when oxygen is available. In this scenario, you need NAD+ regeneration."
          : "Not quite. Lactate is best when oxygen is limited or demand is very high. Here, oxygen is adequate for aerobic routing.";
        setFinaleStatus(explain + ` ${SETTINGS.scoreFinaleWrong}.`, "bad");
        beep("bad");
      }
    }

    // =========================
    // RESET AND MODE
    // =========================
    function setStart(start){
      state.start = start;
      state.attempts = 0;
      state.hintLevel = 0;
      state.history = [];
      state.selectedCardId = null;
      state.finaleUnlocked = false;
      state.currentScenario = null;

      startNote.textContent = START_NOTES[start];

      el("glucoseToggle").classList.toggle("active", start === "glucose");
      el("glycogenToggle").classList.toggle("active", start === "glycogen");

      buildSlots();
      buildPool();
      computeEnergyAndProgress();
      setStatus("Build your pathway, then click Check. Perfect unlocks the pyruvate finale.", "warn");
    }

    function setMode(mode){
      state.mode = mode;
      state.hintsLeft = (mode === "study") ? SETTINGS.hintsStudy : SETTINGS.hintsChallenge;

      el("studyToggle").classList.toggle("active", mode === "study");
      el("challengeToggle").classList.toggle("active", mode === "challenge");

      const focus = (mode === "study")
        ? "Anchor the order with irreversible steps (HK, PFK 1, PK). NADH is made at GAPDH. ATP is made at PGK and PK."
        : "Challenge mode: fewer hints. Build fast. Then check.";

      el("focusText").textContent = focus;

      computeEnergyAndProgress();
      showToast(mode === "study" ? "Study mode." : "Challenge mode.");
      beep("click");
    }

    function resetAll(){
      state.score = 0;
      state.streak = 0;
      state.badges = new Set();
      state.attempts = 0;
      state.hintLevel = 0;
      state.history = [];
      state.selectedCardId = null;
      state.finaleUnlocked = false;
      state.finaleSolvedCount = 0;

      scoreVal.textContent = "0";
      streakVal.textContent = "0";
      badgesTag.textContent = "Badges: 0";

      timerStop();
      state.t0 = performance.now();
      state.elapsed = 0;
      updateTimeUI();

      setMode(state.mode);  // resets hints
      setStart(state.start);
      showToast("Reset.");
      beep("click");
    }

    function shufflePool(){
      const cards = [...pool.querySelectorAll(".card")];
      const shuffled = shuffle(cards);
      pool.innerHTML = "";
      for (const c of shuffled) pool.appendChild(c);
      showToast("Shuffled.");
      beep("click");
    }

    // =========================
    // EVENTS
    // =========================
    el("glucoseToggle").addEventListener("click", () => setStart("glucose"));
    el("glycogenToggle").addEventListener("click", () => setStart("glycogen"));

    el("studyToggle").addEventListener("click", () => setMode("study"));
    el("challengeToggle").addEventListener("click", () => setMode("challenge"));

    el("resetBtn").addEventListener("click", resetAll);
    el("checkBtn").addEventListener("click", checkPathway);
    el("hintBtn").addEventListener("click", hint);
    el("shuffleBtn").addEventListener("click", shufflePool);
    el("undoBtn").addEventListener("click", undo);

    el("soundBtn").addEventListener("click", () => {
      state.soundOn = !state.soundOn;
      el("soundBtn").textContent = "Sound: " + (state.soundOn ? "On" : "Off");
      showToast(state.soundOn ? "Sound on." : "Sound off.");
    });

    el("confettiBtn").addEventListener("click", () => {
      state.confettiOn = !state.confettiOn;
      el("confettiBtn").textContent = "Confetti: " + (state.confettiOn ? "On" : "Off");
      showToast(state.confettiOn ? "Confetti on." : "Confetti off.");
    });

    el("closeOverlayBtn").addEventListener("click", () => overlay.classList.remove("show"));
    el("newScenarioBtn").addEventListener("click", () => {
      state.currentScenario = pickScenario();
      scenarioBox.innerHTML = `
        <div style="font-weight:900; margin-bottom: 6px; color: rgba(255,255,255,0.95);">Scenario</div>
        <div style="color: rgba(255,255,255,0.80); line-height: 1.45;">${escapeHtml(state.currentScenario.prompt)}</div>
      `;
      setFinaleStatus("Pick the best fate for pyruvate based on the scenario.", "warn");
      beep("click");
    });

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) overlay.classList.remove("show");
    });

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "enter") checkPathway();
      if (k === "h") hint();
      if (k === "r") resetAll();
      if (k === "u") undo();
      if (k === "escape") overlay.classList.remove("show");
    });

    // Click background clears selection
    window.addEventListener("click", () => {
      if (state.selectedCardId){
        state.selectedCardId = null;
        refreshSelectionUI();
      }
    });

    // =========================
    // INIT
    // =========================
    function init(){
      resizeConfetti();
      el("soundBtn").textContent = "Sound: On";
      el("confettiBtn").textContent = "Confetti: On";
      badgesTag.textContent = "Badges: 0";
      setMode("study");
      setStart("glucose");
      setStatus("Build your pathway, then click Check. Perfect unlocks the pyruvate finale.", "warn");
      computeEnergyAndProgress();
    }

    init();
  </script>
</body>
</html>
