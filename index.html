<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Glycolysis Builder Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --bg1:#0b1020;
      --border: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);
      --gold:#c9b037;
      --good:#45d483;
      --bad:#ff6b6b;
      --warn:#ffcc66;

      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.08);
      --shadow: 0 22px 52px rgba(0,0,0,0.45);
      --radius: 18px;

      --btn: rgba(255,255,255,0.08);
      --btnHover: rgba(255,255,255,0.13);
      --kbd: rgba(0,0,0,0.28);
    }

    *{ box-sizing: border-box; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 700px at 20% 0%, #1a2452 0%, var(--bg1) 48%, #070a14 100%);
      min-height:100vh;
      padding: 18px;
    }

    .wrap{ max-width: 1220px; margin: 0 auto; }

    .top{
      display:flex;
      gap:14px;
      align-items:flex-end;
      justify-content: space-between;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    h1{
      margin:0;
      font-size: 24px;
      letter-spacing: -0.4px;
    }

    .sub{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
      max-width: 820px;
    }

    .bar{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:flex-end;
    }

    .pill{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.05);
      padding: 9px 12px;
      border-radius: 999px;
      display:flex;
      gap:8px;
      align-items:center;
      font-size: 13px;
    }
    .pill strong{ color: white; font-weight: 900; }

    .btn{
      border:1px solid var(--border);
      background: var(--btn);
      color: white;
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 800;
      user-select:none;
    }
    .btn:hover{ background: var(--btnHover); }
    .btn.primary{
      background: rgba(201,176,55,0.92);
      color: #0b1020;
      border-color: rgba(201,176,55,0.85);
    }
    .btn.primary:hover{ background: rgba(201,176,55,1); }

    .grid{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 12px;
    }
    @media (max-width: 1000px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .panelHeader{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .panelHeader h2{
      margin:0;
      font-size: 15px;
      letter-spacing: -0.2px;
      color: rgba(255,255,255,0.95);
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .tag{
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      white-space: nowrap;
    }

    .panelBody{ padding: 14px 16px 16px; }

    .row{ display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .hr{ height:1px; background: var(--border); margin: 12px 0; }

    .toggleGroup{
      display:flex;
      border:1px solid var(--border);
      border-radius: 999px;
      overflow:hidden;
    }
    .toggle{
      padding: 9px 12px;
      cursor:pointer;
      user-select:none;
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      border-right: 1px solid var(--border);
      font-weight: 900;
      font-size: 13px;
    }
    .toggle:last-child{ border-right: none; }
    .toggle.active{
      background: rgba(201,176,55,0.92);
      color: #0b1020;
    }

    .kbd{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--kbd);
      font-size: 11px;
      color: rgba(255,255,255,0.78);
      font-weight: 900;
      margin: 0 2px;
    }

    .helpWrap{
      margin-top: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.22);
      border-radius: 16px;
      padding: 10px 12px;
      display:none;
    }
    .instruction{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
    }

    .statsGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 850px){
      .statsGrid{ grid-template-columns: repeat(2, 1fr); }
    }
    .stat{
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .stat .k{ font-size: 11px; color: rgba(255,255,255,0.70); }
    .stat .v{ font-weight: 950; font-size: 16px; margin-top: 2px; }
    .stat.good .v{ color: var(--good); }
    .stat.gold .v{ color: rgba(201,176,55,0.98); }

    .progressWrap{
      margin-top: 10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .progressBar{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      overflow:hidden;
      margin-top: 8px;
    }
    .progressFill{
      height: 100%;
      width: 0%;
      background: rgba(201,176,55,0.92);
      border-radius: 999px;
      transition: width 160ms ease;
    }
    .miniText{
      margin-top: 6px;
      font-size: 12px;
      color: rgba(255,255,255,0.68);
      line-height: 1.35;
    }

    /* Slots */
    .slots{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }
    .slot{
      border:1px dashed rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
      min-height: 66px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      transition: 120ms ease;
    }
    .slot.dragOver{
      border-color: rgba(201,176,55,0.9);
      background: rgba(201,176,55,0.12);
      transform: translateY(-1px);
    }
    .slotLeft{
      display:flex;
      gap:10px;
      align-items:center;
      min-width: 140px;
    }
    .slotNum{
      width: 28px; height: 28px;
      border-radius: 12px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.06);
      font-weight: 950;
    }
    .slotLabel{
      display:flex; flex-direction: column;
      gap: 2px;
    }
    .slotLabel .main{
      font-weight: 950;
      font-size: 12px;
      color: rgba(255,255,255,0.86);
    }
    .slotLabel .sub{
      font-size: 11px;
      color: rgba(255,255,255,0.62);
      max-width: 320px;
    }
    .slotRight{
      flex:1;
      display:flex;
      justify-content:flex-end;
      min-height: 44px;
      align-items:center;
      gap: 10px;
    }
    .slotBadge{
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: rgba(255,255,255,0.76);
      background: rgba(255,255,255,0.05);
      white-space: nowrap;
    }
    .slotBadge.good{ border-color: rgba(69,212,131,0.45); background: rgba(69,212,131,0.12); color: rgba(255,255,255,0.92); }
    .slotBadge.bad{ border-color: rgba(255,107,107,0.55); background: rgba(255,107,107,0.12); color: rgba(255,255,255,0.92); }
    .slotBadge.warn{ border-color: rgba(255,204,102,0.50); background: rgba(255,204,102,0.12); color: rgba(255,255,255,0.92); }

    /* Cards */
    .card{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: 10px 12px;
      display:flex;
      flex-direction: column;
      gap: 5px;
      cursor: grab;
      user-select:none;
      max-width: 560px;
    }
    .card:active{ cursor: grabbing; }
    .card.selected{
      outline: 2px solid rgba(201,176,55,0.85);
      background: rgba(201,176,55,0.10);
    }
    .card .name{
      font-weight: 950;
      font-size: 14px;
      color: rgba(255,255,255,0.95);
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }
    .chip{
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.16);
      color: rgba(255,255,255,0.74);
      font-weight: 900;
    }
    .chip.gold{ border-color: rgba(201,176,55,0.55); color: rgba(201,176,55,0.98); }
    .chip.good{ border-color: rgba(69,212,131,0.45); color: rgba(69,212,131,0.96); }

    .card .meta{
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      line-height: 1.35;
    }

    .pool{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }
    .poolGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      min-height: 160px;
    }

    .status{
      margin-top: 10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px 12px;
      color: rgba(255,255,255,0.86);
      font-size: 13px;
      line-height: 1.4;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      align-items:flex-start;
    }
    .status.good{ border-color: rgba(69,212,131,0.45); background: rgba(69,212,131,0.12); }
    .status.bad{ border-color: rgba(255,107,107,0.55); background: rgba(255,107,107,0.12); }
    .status.warn{ border-color: rgba(255,204,102,0.50); background: rgba(255,204,102,0.12); }
    .status .rightNote{
      color: rgba(255,255,255,0.72);
      font-size: 12px;
      white-space: nowrap;
    }

    /* Overlay modal, fixed readability */
    .overlay{
      position: fixed;
      inset:0;
      background: rgba(0,0,0,0.80);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 30;
    }
    .overlay.show{ display:flex; }

    .modal{
      width: min(900px, 100%);
      max-height: min(86vh, 780px);
      overflow: hidden;
      border-radius: 22px;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(16, 20, 38, 0.97);
      box-shadow: 0 30px 90px rgba(0,0,0,0.75);
    }
    .modalHeader{
      padding: 16px 18px;
      border-bottom: 1px solid rgba(255,255,255,0.14);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modalHeader h3{ margin:0; font-size: 16px; }
    .modalBody{
      padding: 16px 18px 18px;
      overflow: auto;
    }

    .scenario{
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      border-radius: 18px;
      padding: 12px 14px;
      margin-bottom: 12px;
      color: rgba(255,255,255,0.94);
    }

    .choices{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 720px){
      .choices{ grid-template-columns: 1fr; }
    }

    .choice{
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.07);
      border-radius: 16px;
      padding: 12px 12px;
      cursor:pointer;
      transition: 120ms ease;
      user-select:none;
    }
    .choice:hover{
      background: rgba(255,255,255,0.12);
      transform: translateY(-1px);
    }
    .choice .ctitle{
      font-weight: 950;
      color: rgba(255,255,255,0.96);
    }
    .choice .cmeta{
      font-size: 12px;
      color: rgba(255,255,255,0.80);
      margin-top: 4px;
      line-height: 1.35;
    }

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.94);
      font-size: 13px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.55);
      z-index: 60;
      display:none;
      max-width: min(680px, 92vw);
    }
    .toast.show{ display:block; }

    /* Confetti canvas */
    #confetti{
      position: fixed;
      inset: 0;
      pointer-events:none;
      z-index: 80;
      display:none;
    }
  </style>
</head>

<body>
  <canvas id="confetti"></canvas>
  <div class="toast" id="toast"></div>

  <div class="wrap">
    <div class="top">
      <div>
        <h1>Glycolysis Builder</h1>
        <div class="sub">
          Build the pathway. See ATP and NADH update. Finale: pyruvate fate.
        </div>
      </div>

      <div class="bar">
        <div class="pill"><strong>Score</strong> <span id="scoreVal">0</span></div>
        <div class="pill"><strong>Time</strong> <span id="timeVal">0:00</span></div>
        <div class="pill"><strong>Badges</strong> <span id="badgesVal">0</span></div>

        <button class="btn" id="helpBtn" title="Show or hide instructions">Help</button>
        <button class="btn" id="soundBtn" title="Toggle sound">Sound: On</button>
        <button class="btn" id="confettiBtn" title="Toggle confetti">Confetti: On</button>

        <button class="btn" id="undoBtn" title="Undo last move">Undo</button>
        <button class="btn" id="shuffleBtn" title="Shuffle pool">Shuffle</button>
        <button class="btn" id="hintBtn" title="Get a hint">Hint</button>
        <button class="btn" id="resetBtn" title="Reset everything">Reset</button>
        <button class="btn primary" id="checkBtn" title="Check pathway">Check</button>
      </div>
    </div>

    <div class="grid">
      <!-- Builder -->
      <div class="panel">
        <div class="panelHeader">
          <h2>
            Build the pathway
            <span class="tag" id="startTag">Start: Glucose</span>
            <span class="tag" id="modeTag">Study</span>
          </h2>

          <div class="row">
            <div class="toggleGroup" aria-label="Start substrate toggle">
              <div class="toggle active" id="glucoseToggle">Glucose</div>
              <div class="toggle" id="glycogenToggle">Glycogen</div>
            </div>

            <div class="toggleGroup" aria-label="Mode toggle">
              <div class="toggle active" id="studyToggle">Study</div>
              <div class="toggle" id="challengeToggle">Challenge</div>
            </div>
          </div>
        </div>

        <div class="panelBody">
          <div class="helpWrap" id="helpWrap">
            <div class="instruction">
              Drag cards into slots. Or click a card to select, then click a slot to place.
              Double click a placed card to send it back to the pool.
              Keyboard: <span class="kbd">Enter</span> checks, <span class="kbd">H</span> hint, <span class="kbd">R</span> reset, <span class="kbd">U</span> undo.
              Goal: correct order and energy logic. Finish to unlock the pyruvate finale.
            </div>
          </div>

          <div class="statsGrid">
            <div class="stat">
              <div class="k">ATP used</div>
              <div class="v" id="atpUsedVal">0</div>
            </div>
            <div class="stat good">
              <div class="k">ATP made</div>
              <div class="v" id="atpMadeVal">0</div>
            </div>
            <div class="stat gold">
              <div class="k">Net ATP</div>
              <div class="v" id="netAtpVal">0</div>
            </div>
            <div class="stat">
              <div class="k">NADH made</div>
              <div class="v" id="nadhVal">0</div>
            </div>
          </div>

          <div class="progressWrap">
            <div class="miniText" id="startNote">
              Starting from glucose: invest 2 ATP, make 4 ATP, net 2 ATP. NADH = 2.
            </div>
            <div class="progressBar" aria-label="Progress bar">
              <div class="progressFill" id="progressFill"></div>
            </div>
            <div class="miniText" id="progressText">Place cards to start.</div>
          </div>

          <div class="hr"></div>

          <div class="slots" id="slots"></div>

          <div class="status warn" id="statusBox">
            <div id="statusMsg">Build your pathway, then click Check. Perfect unlocks the pyruvate finale.</div>
            <div class="rightNote" id="hintNote">Hints left: 3</div>
          </div>
        </div>
      </div>

      <!-- Pool -->
      <div class="panel">
        <div class="panelHeader">
          <h2>Card pool <span class="tag">Drag or click</span></h2>
          <div class="tag" id="poolCount">0 cards</div>
        </div>

        <div class="panelBody">
          <div class="pool">
            <div class="poolGrid" id="pool"></div>
          </div>

          <div class="hr"></div>

          <div class="instruction" style="color: rgba(255,255,255,0.66);">
            Short version: HK and PFK use ATP. GAPDH makes NADH. PGK and PK make ATP. Glycogen entry skips the HK ATP cost.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Finale modal -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHeader">
        <h3>Finale: fate of pyruvate</h3>
        <div class="row">
          <button class="btn" id="newScenarioBtn">New scenario</button>
          <button class="btn" id="closeOverlayBtn">Close</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="scenario" id="scenarioBox"></div>
        <div class="choices" id="choices"></div>
        <div class="status warn" id="finaleFeedback" style="margin-top: 12px;">
          Pick the best fate for pyruvate based on the scenario.
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // TEACHER SETTINGS
    // =========================
    const SETTINGS = {
      scorePerfectBase: 25,
      scorePerfectDecay: 5,
      scoreWrongCheck: -3,
      scoreHint: -1,
      scoreFinaleCorrect: 10,
      scoreFinaleWrong: -2,
      hintsStudy: 3,
      hintsChallenge: 1,
      confettiParticles: 130
    };

    // Compact pathway (easier for your level). Glycogen mode skips HK (bypass ATP cost).
    const CARDS = [
      { id:"start_glucose", name:"Start: Glucose", meta:"Glucose is available in cytosol.", chips:["START"], onlyWhen:"glucose", effects:{} },
      { id:"start_glycogen", name:"Start: Glycogen entry", meta:"Glycogen -> G1P -> G6P. Bypasses HK ATP cost.", chips:["START","BYPASS HK"], onlyWhen:"glycogen", effects:{} },

      { id:"hk", name:"Hexokinase (HK)", meta:"Glucose -> G6P. ATP used. Traps glucose in cell.", chips:["ATP USE","IRREV"], effects:{ atpUsed: 1 } },
      { id:"pfk", name:"PFK 1", meta:"F6P -> F1,6BP. ATP used. Major control point.", chips:["ATP USE","CONTROL","IRREV"], effects:{ atpUsed: 1 } },
      { id:"split", name:"Split and rearrange", meta:"F1,6BP -> 2 x triose phosphates. Sets up payoff.", chips:["2X"], effects:{} },
      { id:"gapdh", name:"GAPDH", meta:"G3P -> 1,3BPG. NAD+ -> NADH (happens twice).", chips:["NADH"], effects:{ nadh: 2 } },
      { id:"pgk", name:"PGK", meta:"1,3BPG -> 3PG. ATP made (happens twice).", chips:["ATP MAKE"], effects:{ atpMade: 2 } },
      { id:"pk", name:"Pyruvate kinase (PK)", meta:"PEP -> Pyruvate. ATP made (happens twice).", chips:["ATP MAKE","IRREV"], effects:{ atpMade: 2 } }
    ];

    const ORDER = {
      glucose: ["start_glucose", "hk", "pfk", "split", "gapdh", "pgk", "pk"],
      glycogen: ["start_glycogen", "pfk", "split", "gapdh", "pgk", "pk"]
    };

    const START_NOTES = {
      glucose: "Starting from glucose: invest 2 ATP, make 4 ATP, net 2 ATP. NADH = 2.",
      glycogen: "Starting from glycogen: bypass HK ATP cost, so net ATP is higher by 1 (net 3). NADH = 2."
    };

    const FATE_CHOICES = [
      { id:"acetylCoA", title:"Acetyl CoA (aerobic)", meta:"Oxygen available. Pyruvate enters mitochondria (PDH) for aerobic ATP production." },
      { id:"lactate", title:"Lactate (anaerobic or very high flux)", meta:"Regenerates NAD+ so glycolysis can continue when oxygen is limited or demand is very high." }
    ];

    const SCENARIOS = [
      { id:"highO2", prompt:"Oxygen is plentiful and mitochondria are ready. You want maximum ATP yield.", correct:"acetylCoA" },
      { id:"steady", prompt:"Moderate intensity with steady breathing. Oxygen is adequate.", correct:"acetylCoA" },
      { id:"lowO2", prompt:"Very low oxygen during an all out sprint. You must regenerate NAD+ fast.", correct:"lactate" },
      { id:"allOut", prompt:"All out effort. Glycolysis is flying and oxygen delivery cannot keep up.", correct:"lactate" }
    ];

    // =========================
    // STATE
    // =========================
    const state = {
      start: "glucose",
      mode: "study",
      score: 0,
      badges: new Set(),
      attempts: 0,
      hintsLeft: SETTINGS.hintsStudy,
      hintLevel: 0,
      placedBySlot: [],
      history: [],
      selectedCardId: null,

      timerOn: false,
      t0: 0,
      elapsed: 0,
      timerHandle: 0,

      finaleUnlocked: false,
      currentScenario: null,

      soundOn: true,
      confettiOn: true
    };

    // =========================
    // ELEMENTS
    // =========================
    const el = (id) => document.getElementById(id);

    const scoreVal = el("scoreVal");
    const timeVal = el("timeVal");
    const badgesVal = el("badgesVal");
    const poolCount = el("poolCount");

    const startTag = el("startTag");
    const modeTag = el("modeTag");
    const startNote = el("startNote");

    const statusBox = el("statusBox");
    const statusMsg = el("statusMsg");
    const hintNote = el("hintNote");

    const atpUsedVal = el("atpUsedVal");
    const atpMadeVal = el("atpMadeVal");
    const netAtpVal = el("netAtpVal");
    const nadhVal = el("nadhVal");

    const progressFill = el("progressFill");
    const progressText = el("progressText");

    const helpWrap = el("helpWrap");
    const pool = el("pool");
    const slots = el("slots");

    const overlay = el("overlay");
    const scenarioBox = el("scenarioBox");
    const choicesEl = el("choices");
    const finaleFeedback = el("finaleFeedback");

    const toast = el("toast");
    const confettiCanvas = el("confetti");
    const ctxConf = confettiCanvas.getContext("2d");

    // =========================
    // UTILS
    // =========================
    function escapeHtml(str){
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function shuffle(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove("show"), 1600);
    }

    function beep(type){
      if (!state.soundOn) return;
      try{
        const ac = new (window.AudioContext || window.webkitAudioContext)();
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.connect(g);
        g.connect(ac.destination);

        let f = 520, dur = 0.06, gain = 0.04;
        if (type === "good"){ f = 680; dur = 0.10; gain = 0.06; }
        if (type === "bad"){ f = 220; dur = 0.10; gain = 0.06; }

        o.frequency.value = f;
        o.type = "sine";
        g.gain.value = gain;

        o.start();
        setTimeout(() => { o.stop(); ac.close(); }, Math.floor(dur * 1000));
      } catch {}
    }

    function setStatus(msg, kind){
      statusBox.classList.remove("good","bad","warn");
      statusBox.classList.add(kind);
      statusMsg.textContent = msg;
    }

    function setFinaleStatus(msg, kind){
      finaleFeedback.classList.remove("good","bad","warn");
      finaleFeedback.classList.add(kind);
      finaleFeedback.textContent = msg;
    }

    // =========================
    // CONFETTI
    // =========================
    function resizeConfetti(){
      confettiCanvas.width = Math.floor(window.innerWidth * Math.min(2, window.devicePixelRatio || 1));
      confettiCanvas.height = Math.floor(window.innerHeight * Math.min(2, window.devicePixelRatio || 1));
      ctxConf.setTransform(1,0,0,1,0,0);
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      ctxConf.scale(dpr, dpr);
    }
    window.addEventListener("resize", resizeConfetti);

    function confettiBurst(){
      if (!state.confettiOn) return;
      resizeConfetti();
      confettiCanvas.style.display = "block";

      const W = window.innerWidth;
      const H = window.innerHeight;

      const parts = [];
      const n = SETTINGS.confettiParticles;

      for (let i = 0; i < n; i++){
        parts.push({
          x: Math.random() * W,
          y: -20 - Math.random() * 200,
          vx: -2 + Math.random() * 4,
          vy: 2 + Math.random() * 5,
          r: 2 + Math.random() * 4,
          a: Math.random() * Math.PI * 2,
          va: -0.2 + Math.random() * 0.4,
          life: 70 + Math.random() * 80
        });
      }

      function tick(){
        ctxConf.clearRect(0,0,W,H);
        for (const p of parts){
          p.x += p.vx;
          p.y += p.vy;
          p.a += p.va;
          p.vy += 0.02;
          p.life--;

          ctxConf.save();
          ctxConf.translate(p.x, p.y);
          ctxConf.rotate(p.a);
          ctxConf.globalAlpha = Math.max(0, Math.min(1, p.life / 60));
          ctxConf.fillStyle = (Math.random() < 0.5) ? "rgba(201,176,55,0.95)" : "rgba(255,255,255,0.85)";
          ctxConf.fillRect(-p.r, -p.r, p.r*2, p.r*2);
          ctxConf.restore();
        }

        if (parts.some(p => p.life > 0 && p.y < H + 40)){
          requestAnimationFrame(tick);
        } else {
          confettiCanvas.style.display = "none";
        }
      }
      requestAnimationFrame(tick);
    }

    // =========================
    // TIMER
    // =========================
    function formatTime(sec){
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m}:${String(s).padStart(2,"0")}`;
    }

    function timerStart(){
      if (state.timerOn) return;
      state.timerOn = true;
      state.t0 = performance.now();
      state.elapsed = 0;
      timeVal.textContent = "0:00";
      state.timerHandle = setInterval(() => {
        state.elapsed = (performance.now() - state.t0) / 1000;
        timeVal.textContent = formatTime(state.elapsed);
      }, 200);
    }

    function timerStop(){
      state.timerOn = false;
      clearInterval(state.timerHandle);
      state.timerHandle = 0;
    }

    // =========================
    // GAME DATA HELPERS
    // =========================
    function getActiveCards(){
      return CARDS.filter(c => !c.onlyWhen || c.onlyWhen === state.start);
    }

    function getOrder(){
      return ORDER[state.start];
    }

    function getCardById(id){
      return CARDS.find(c => c.id === id);
    }

    function chipsHTML(card){
      const chips = (card.chips || []).map(ch => {
        let cls = "chip";
        if (ch.includes("ATP") || ch.includes("NADH")) cls += " good";
        if (ch.includes("IRREV") || ch.includes("CONTROL") || ch.includes("BYPASS")) cls += " gold";
        return `<span class="${cls}">${escapeHtml(ch)}</span>`;
      }).join("");
      return chips;
    }

    // =========================
    // BUILD UI
    // =========================
    function buildSlots(){
      slots.innerHTML = "";
      const order = getOrder();
      state.placedBySlot = new Array(order.length).fill(null);

      for (let i = 0; i < order.length; i++){
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.slotIndex = String(i);

        const left = document.createElement("div");
        left.className = "slotLeft";

        const num = document.createElement("div");
        num.className = "slotNum";
        num.textContent = String(i + 1);

        const label = document.createElement("div");
        label.className = "slotLabel";

        const main = document.createElement("div");
        main.className = "main";
        main.textContent = (i === 0) ? "Entry" : (i <= 2 ? "Early" : (i === 3 ? "Split" : "Payoff"));

        const sub = document.createElement("div");
        sub.className = "sub";
        sub.textContent = "Drop a card here";

        label.appendChild(main);
        label.appendChild(sub);

        left.appendChild(num);
        left.appendChild(label);

        const right = document.createElement("div");
        right.className = "slotRight";

        const badge = document.createElement("div");
        badge.className = "slotBadge warn";
        badge.textContent = "Empty";

        const content = document.createElement("div");
        content.dataset.dropzone = "slot";
        content.style.display = "flex";
        content.style.justifyContent = "flex-end";

        right.appendChild(badge);
        right.appendChild(content);

        slot.appendChild(left);
        slot.appendChild(right);

        slot.addEventListener("dragover", (e) => {
          e.preventDefault();
          slot.classList.add("dragOver");
        });
        slot.addEventListener("dragleave", () => slot.classList.remove("dragOver"));
        slot.addEventListener("drop", (e) => {
          e.preventDefault();
          slot.classList.remove("dragOver");
          const cardId = e.dataTransfer.getData("text/plain");
          if (cardId) placeCardIntoSlot(cardId, i, "drag");
        });

        slot.addEventListener("click", () => {
          if (state.selectedCardId){
            placeCardIntoSlot(state.selectedCardId, i, "click");
          }
        });

        slots.appendChild(slot);
      }
    }

    function buildPool(){
      pool.innerHTML = "";
      const active = shuffle(getActiveCards());
      for (const c of active){
        pool.appendChild(makeCard(c));
      }
      poolCount.textContent = `${active.length} cards`;

      pool.addEventListener("dragover", (e) => e.preventDefault());
      pool.addEventListener("drop", (e) => {
        e.preventDefault();
        const cardId = e.dataTransfer.getData("text/plain");
        if (cardId) moveCardToPool(cardId, true);
      });
    }

    function makeCard(card){
      const d = document.createElement("div");
      d.className = "card";
      d.draggable = true;
      d.dataset.cardId = card.id;

      d.innerHTML = `
        <div class="name">${escapeHtml(card.name)} ${chipsHTML(card)}</div>
        <div class="meta">${escapeHtml(card.meta)}</div>
      `;

      d.addEventListener("dragstart", (e) => {
        e.dataTransfer.setData("text/plain", card.id);
        e.dataTransfer.effectAllowed = "move";
        beep("click");
      });

      d.addEventListener("click", (e) => {
        e.stopPropagation();
        selectCard(card.id);
        beep("click");
      });

      d.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        const fromSlot = findCardSlotIndex(card.id);
        if (fromSlot !== -1){
          moveCardToPool(card.id, true);
          pushHistory({ type:"toPool", cardId: card.id, fromSlot });
        }
      });

      return d;
    }

    function refreshSelectionUI(){
      document.querySelectorAll(".card").forEach(c => c.classList.remove("selected"));
      if (state.selectedCardId){
        const elCard = findCardElement(state.selectedCardId);
        if (elCard) elCard.classList.add("selected");
      }
    }

    function selectCard(cardId){
      state.selectedCardId = (state.selectedCardId === cardId) ? null : cardId;
      refreshSelectionUI();
    }

    function findCardElement(cardId){
      return document.querySelector(`[data-card-id="${cardId}"]`);
    }

    function findCardSlotIndex(cardId){
      return state.placedBySlot.findIndex(id => id === cardId);
    }

    function setSlotBadge(i, kind, text){
      const slot = document.querySelector(`.slot[data-slot-index="${i}"]`);
      if (!slot) return;
      const badge = slot.querySelector(".slotBadge");
      badge.classList.remove("good","bad","warn");
      badge.classList.add(kind);
      badge.textContent = text;
    }

    // =========================
    // HISTORY AND UNDO
    // =========================
    function pushHistory(entry){
      state.history.push(entry);
      if (state.history.length > 80) state.history.shift();
    }

    function undo(){
      const h = state.history.pop();
      if (!h){
        showToast("Nothing to undo.");
        return;
      }

      if (h.type === "place"){
        if (h.toSlotIndex != null){
          clearSlot(h.toSlotIndex);
        }
        if (h.fromSlotIndex != null){
          placeCardIntoSlot(h.cardId, h.fromSlotIndex, "undo", true);
        } else {
          moveCardToPool(h.cardId, false);
        }
        if (h.bumpedCardId){
          placeCardIntoSlot(h.bumpedCardId, h.toSlotIndex, "undo", true);
        }
      }

      if (h.type === "toPool"){
        placeCardIntoSlot(h.cardId, h.fromSlot, "undo", true);
      }

      computeEnergyAndProgress();
      state.selectedCardId = null;
      refreshSelectionUI();
      showToast("Undo.");
      beep("click");
    }

    // =========================
    // PLACE AND MOVE
    // =========================
    function clearSlot(slotIndex){
      const slotContent = document.querySelector(`.slot[data-slot-index="${slotIndex}"] [data-dropzone="slot"]`);
      if (slotContent) slotContent.innerHTML = "";
      state.placedBySlot[slotIndex] = null;
      setSlotBadge(slotIndex, "warn", "Empty");
    }

    function placeCardIntoSlot(cardId, slotIndex, source, silent){
      const cardEl = findCardElement(cardId);
      if (!cardEl) return;

      timerStart();

      // If already in another slot, clear that slot
      const existingSlot = findCardSlotIndex(cardId);
      if (existingSlot !== -1){
        clearSlot(existingSlot);
      }

      // If target has a card, bump to pool
      const existingInTarget = state.placedBySlot[slotIndex];
      let bumpedCardId = null;
      if (existingInTarget){
        bumpedCardId = existingInTarget;
        moveCardToPool(existingInTarget, false);
        clearSlot(slotIndex);
      }

      // Place
      state.placedBySlot[slotIndex] = cardId;
      const slotContent = document.querySelector(`.slot[data-slot-index="${slotIndex}"] [data-dropzone="slot"]`);
      slotContent.innerHTML = "";
      slotContent.appendChild(cardEl);

      if (source !== "undo"){
        pushHistory({
          type:"place",
          cardId,
          fromSlotIndex: existingSlot !== -1 ? existingSlot : null,
          toSlotIndex: slotIndex,
          bumpedCardId
        });
      }

      if (source === "click"){
        state.selectedCardId = null;
        refreshSelectionUI();
      }

      if (!silent){
        setStatus("Keep going, then check when ready.", "warn");
        beep("click");
      }

      setSlotBadge(slotIndex, "warn", "Placed");
      computeEnergyAndProgress();
    }

    function moveCardToPool(cardId, clearFromSlot){
      const cardEl = findCardElement(cardId);
      if (!cardEl) return;

      const slotIndex = findCardSlotIndex(cardId);
      if (slotIndex !== -1 && clearFromSlot){
        clearSlot(slotIndex);
      }

      pool.prepend(cardEl);
      if (state.selectedCardId === cardId){
        state.selectedCardId = null;
        refreshSelectionUI();
      }
    }

    // =========================
    // ENERGY AND PROGRESS
    // =========================
    function computeEnergyAndProgress(){
      let atpUsed = 0, atpMade = 0, nadh = 0;

      for (const id of state.placedBySlot){
        if (!id) continue;
        const card = getCardById(id);
        if (!card || !card.effects) continue;
        atpUsed += (card.effects.atpUsed || 0);
        atpMade += (card.effects.atpMade || 0);
        nadh += (card.effects.nadh || 0);
      }

      const netAtp = atpMade - atpUsed;

      atpUsedVal.textContent = String(atpUsed);
      atpMadeVal.textContent = String(atpMade);
      netAtpVal.textContent = String(netAtp);
      nadhVal.textContent = String(nadh);

      const filled = state.placedBySlot.filter(Boolean).length;
      const total = state.placedBySlot.length;
      const pct = total ? Math.round((filled / total) * 100) : 0;
      progressFill.style.width = pct + "%";
      progressText.textContent = filled === 0 ? "Place cards to start." : `Placed ${filled} of ${total}.`;

      hintNote.textContent = `Hints left: ${state.hintsLeft}`;
      startTag.textContent = "Start: " + (state.start === "glucose" ? "Glucose" : "Glycogen");
      modeTag.textContent = (state.mode === "study") ? "Study" : "Challenge";
      startNote.textContent = START_NOTES[state.start];
    }

    // =========================
    // SCORING AND BADGES
    // =========================
    function updateScore(delta){
      state.score += delta;
      if (state.score < 0) state.score = 0;
      scoreVal.textContent = String(state.score);
    }

    function awardBadge(key){
      if (state.badges.has(key)) return;
      state.badges.add(key);
      badgesVal.textContent = String(state.badges.size);
      showToast("Badge earned: " + key);
    }

    // =========================
    // CHECK PATHWAY
    // =========================
    function checkPathway(){
      const correct = getOrder();
      const placed = state.placedBySlot;

      const emptyCount = placed.filter(x => !x).length;
      if (emptyCount > 0){
        setStatus(`Fill all slots first. Empty slots: ${emptyCount}.`, "warn");
        beep("bad");
        return;
      }

      state.attempts += 1;

      let right = 0;
      for (let i = 0; i < correct.length; i++){
        const ok = placed[i] === correct[i];
        if (ok) right++;
        setSlotBadge(i, ok ? "good" : "bad", ok ? "Correct" : "Wrong");
      }

      if (right === correct.length){
        const bonus = Math.max(10, SETTINGS.scorePerfectBase - (state.attempts - 1) * SETTINGS.scorePerfectDecay);
        updateScore(bonus);

        if (state.attempts === 1) awardBadge("First Try");
        if (state.hintLevel === 0) awardBadge("No Hints");
        if (state.elapsed > 0 && state.elapsed <= 90) awardBadge("Fast Finish");

        setStatus(`Correct. Bonus +${bonus}. Finale unlocked.`, "good");
        beep("good");
        confettiBurst();

        state.finaleUnlocked = true;
        openFinale();
      } else {
        updateScore(SETTINGS.scoreWrongCheck);
        setStatus(`Not quite. You have ${right}/${correct.length} correct. Adjust and try again.`, "bad");
        beep("bad");
      }
    }

    // =========================
    // HINTS
    // =========================
    function hint(){
      if (state.hintsLeft <= 0){
        showToast("No hints left.");
        beep("bad");
        return;
      }
      state.hintsLeft -= 1;
      state.hintLevel += 1;
      updateScore(SETTINGS.scoreHint);

      if (state.hintLevel === 1){
        setStatus("Hint: Start card first. PFK 1 is early and is the main control point.", "warn");
      } else if (state.hintLevel === 2){
        setStatus("Hint: NADH is made at GAPDH. ATP is made at PGK and PK.", "warn");
      } else {
        setStatus("Hint: Split happens before payoff. Payoff is GAPDH then PGK then PK.", "warn");
      }
      computeEnergyAndProgress();
      beep("click");
    }

    // =========================
    // FINALE
    // =========================
    function pickScenario(){
      return SCENARIOS[Math.floor(Math.random() * SCENARIOS.length)];
    }

    function openFinale(){
      if (!state.finaleUnlocked) return;

      state.currentScenario = pickScenario();
      scenarioBox.innerHTML = `
        <div style="font-weight:950; margin-bottom: 6px;">Scenario</div>
        <div style="color: rgba(255,255,255,0.88); line-height: 1.45;">${escapeHtml(state.currentScenario.prompt)}</div>
      `;

      choicesEl.innerHTML = "";
      for (const c of shuffle(FATE_CHOICES)){
        const div = document.createElement("div");
        div.className = "choice";
        div.innerHTML = `
          <div class="ctitle">${escapeHtml(c.title)}</div>
          <div class="cmeta">${escapeHtml(c.meta)}</div>
        `;
        div.addEventListener("click", () => chooseFate(c.id));
        choicesEl.appendChild(div);
      }

      setFinaleStatus("Pick the best fate for pyruvate based on the scenario.", "warn");
      overlay.classList.add("show");
    }

    function chooseFate(choiceId){
      const s = state.currentScenario;
      if (!s) return;

      if (choiceId === s.correct){
        updateScore(SETTINGS.scoreFinaleCorrect);
        setFinaleStatus(`Correct. +${SETTINGS.scoreFinaleCorrect}.`, "good");
        beep("good");
        confettiBurst();
      } else {
        updateScore(SETTINGS.scoreFinaleWrong);
        const explain = (choiceId === "acetylCoA")
          ? "Not quite. That is best when oxygen is available."
          : "Not quite. Lactate is best when oxygen is limited or demand is extremely high.";
        setFinaleStatus(`${explain} ${SETTINGS.scoreFinaleWrong}.`, "bad");
        beep("bad");
      }
    }

    // =========================
    // MODE AND RESET
    // =========================
    function setStart(start){
      state.start = start;
      state.attempts = 0;
      state.hintLevel = 0;
      state.history = [];
      state.selectedCardId = null;
      state.finaleUnlocked = false;

      el("glucoseToggle").classList.toggle("active", start === "glucose");
      el("glycogenToggle").classList.toggle("active", start === "glycogen");

      buildSlots();
      buildPool();
      computeEnergyAndProgress();
      setStatus("Build your pathway, then click Check. Perfect unlocks the pyruvate finale.", "warn");
    }

    function setMode(mode){
      state.mode = mode;
      state.hintsLeft = (mode === "study") ? SETTINGS.hintsStudy : SETTINGS.hintsChallenge;

      el("studyToggle").classList.toggle("active", mode === "study");
      el("challengeToggle").classList.toggle("active", mode === "challenge");

      computeEnergyAndProgress();
      showToast(mode === "study" ? "Study mode." : "Challenge mode.");
      beep("click");
    }

    function resetAll(){
      state.score = 0;
      state.badges = new Set();
      state.attempts = 0;
      state.hintsLeft = (state.mode === "study") ? SETTINGS.hintsStudy : SETTINGS.hintsChallenge;
      state.hintLevel = 0;
      state.history = [];
      state.selectedCardId = null;
      state.finaleUnlocked = false;

      scoreVal.textContent = "0";
      badgesVal.textContent = "0";

      timerStop();
      state.timerOn = false;
      state.elapsed = 0;
      timeVal.textContent = "0:00";

      setStart(state.start);
      setStatus("Build your pathway, then click Check. Perfect unlocks the pyruvate finale.", "warn");
      showToast("Reset.");
      beep("click");
    }

    function shufflePool(){
      const cards = [...pool.querySelectorAll(".card")];
      const shuffled = shuffle(cards);
      pool.innerHTML = "";
      for (const c of shuffled) pool.appendChild(c);
      showToast("Shuffled.");
      beep("click");
    }

    // =========================
    // EVENTS
    // =========================
    el("helpBtn").addEventListener("click", () => {
      const showing = helpWrap.style.display !== "none";
      helpWrap.style.display = showing ? "none" : "block";
      showToast(showing ? "Help hidden." : "Help shown.");
      beep("click");
    });

    el("soundBtn").addEventListener("click", () => {
      state.soundOn = !state.soundOn;
      el("soundBtn").textContent = "Sound: " + (state.soundOn ? "On" : "Off");
      showToast(state.soundOn ? "Sound on." : "Sound off.");
    });

    el("confettiBtn").addEventListener("click", () => {
      state.confettiOn = !state.confettiOn;
      el("confettiBtn").textContent = "Confetti: " + (state.confettiOn ? "On" : "Off");
      showToast(state.confettiOn ? "Confetti on." : "Confetti off.");
    });

    el("glucoseToggle").addEventListener("click", () => setStart("glucose"));
    el("glycogenToggle").addEventListener("click", () => setStart("glycogen"));

    el("studyToggle").addEventListener("click", () => setMode("study"));
    el("challengeToggle").addEventListener("click", () => setMode("challenge"));

    el("undoBtn").addEventListener("click", undo);
    el("shuffleBtn").addEventListener("click", shufflePool);
    el("hintBtn").addEventListener("click", hint);
    el("resetBtn").addEventListener("click", resetAll);
    el("checkBtn").addEventListener("click", checkPathway);

    el("closeOverlayBtn").addEventListener("click", () => overlay.classList.remove("show"));
    el("newScenarioBtn").addEventListener("click", () => openFinale());

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) overlay.classList.remove("show");
    });

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "enter") checkPathway();
      if (k === "h") hint();
      if (k === "r") resetAll();
      if (k === "u") undo();
      if (k === "escape") overlay.classList.remove("show");
    });

    // Click background clears selection
    window.addEventListener("click", () => {
      if (state.selectedCardId){
        state.selectedCardId = null;
        refreshSelectionUI();
      }
    });

    // =========================
    // INIT
    // =========================
    function init(){
      resizeConfetti();
      el("soundBtn").textContent = "Sound: On";
      el("confettiBtn").textContent = "Confetti: On";
      badgesVal.textContent = "0";
      helpWrap.style.display = "none";
      setMode("study");
      setStart("glucose");
      computeEnergyAndProgress();
    }

    init();
  </script>
</body>
</html>
